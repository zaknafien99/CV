
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Invaders Game</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            font-family: Arial, sans-serif;
            background-color: #f3f3f3;
        }
        h1 {
            color: #333; /* Keep this as is, or change if body background changes drastically */
        }
        #game-info p { /* Style for game info text */
            color: #eee; /* Light color for text on dark body/canvas background */
            margin: 5px 0;
        }
        #game-info { /* Container for game info */
            background-color: rgba(0,0,0,0.5); /* Semi-transparent dark background for the info box */
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px; /* Space between info and canvas */
        }
        body { /* Modified body for better contrast with game info if needed */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            font-family: Arial, sans-serif;
            background-color: #1a1a1a; /* Darker page background */
        }
        canvas {
            border: 1px solid #555; /* Slightly lighter border for dark canvas */
            background-color: #000000; /* Black background for the canvas itself */
        }
    </style>
</head>
<body>
    <h1>Space Invaders Game</h1>
    <div id="game-info">
        <p>Use Arrow Keys to Move, Spacebar to Shoot.</p>
        <p>Score: <span id='score'>0</span></p>
        <p>Level: <span id='level'>1</span></p>
        <p>Lives: <span id='lives'>3</span></p>
    </div>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <a href="index.html">Back to Home</a>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const context = canvas.getContext('2d');

        // AudioContext setup
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx;
        try {
            audioCtx = new AudioContext();
        } catch (e) {
            console.error("Web Audio API is not supported in this browser or AudioContext could not be created.", e);
            // Sound functions will check if audioCtx is available
        }

        function playShootSound() {
            if (!audioCtx) return;
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.type = 'triangle';
            oscillator.frequency.setValueAtTime(880, audioCtx.currentTime); // A5 note
            oscillator.frequency.exponentialRampToValueAtTime(440, audioCtx.currentTime + 0.1); // Ramp down to A4

            gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime); // Start with some volume
            gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 0.1); // Fade out quickly

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + 0.1);
        }

        function playExplosionSound() {
            if (!audioCtx) return;
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.type = 'sawtooth'; // Harsher sound
            oscillator.frequency.setValueAtTime(200, audioCtx.currentTime); // Low frequency
            oscillator.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.15); // Ramp down

            gainNode.gain.setValueAtTime(0.15, audioCtx.currentTime); // Start with some volume
            gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 0.15); // Fade out

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + 0.15);
        }

        const playerShip = {
            width: 40,
            height: 20,
            x: canvas.width / 2 - 20, // Centered
            y: canvas.height - 20 - 10, // At the bottom with padding
            speed: 5,
            color: '#00FF00', // Green for ship
            lives: 3,
            state: 'alive', // 'alive', 'exploding', 'respawning'
            explodeTime: 0
        };

        const playerExplosionSprite = [
            [0,0,1,1,1,1,0,0],
            [0,1,1,1,1,1,1,0],
            [1,1,0,1,1,0,1,1],
            [1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1],
            [1,1,0,1,1,0,1,1],
            [0,1,1,1,1,1,1,0],
            [0,0,1,1,1,1,0,0],
        ];

        const bulletProperties = {
            width: 3,
            height: 7,
            speed: 8,
            color: '#FFFFFF' // White for bullets
        };

        let bullets = [];

        const alienSprites = [
            [ // Squid
                [0,0,1,1,1,1,0,0],[0,1,1,1,1,1,1,0],[1,1,1,1,1,1,1,1],[1,1,1,0,0,1,1,1],[1,1,1,1,1,1,1,1],[0,0,1,0,0,1,0,0],[0,1,0,1,1,0,1,0],[1,0,1,0,0,1,0,1]
            ],
            [ // Crab
                [0,1,1,1,1,1,1,0],[1,1,1,1,1,1,1,1],[1,0,1,1,1,1,0,1],[1,1,1,1,1,1,1,1],[0,1,1,1,1,1,1,0],[0,0,1,0,0,1,0,0],[0,1,0,1,1,0,1,0],[1,0,1,0,0,1,0,1]
            ],
            [ // Octopus
                [0,1,1,1,1,1,1,0],[1,1,1,1,1,1,1,1],[1,0,1,1,1,1,0,1],[1,1,1,1,1,1,1,1],[0,1,1,1,1,1,1,0],[1,0,1,0,0,1,0,1],[0,1,0,1,1,0,1,0],[1,0,1,0,0,1,0,1]
            ]
        ];

        let invaderRowCount = 3;

        const invaderProperties = {
            width: 24,
            height: 24,
            color: '#FFFFFF', // White for invaders
            padding: 10,
            columnCount: 8,
            offsetTop: 30,
            offsetLeft: 30,
            speed: 1,
            moveDirection: 1 // 1 for right, -1 for left
        };

        const bunkerSize = 8; // size of a bunker 'pixel'
        const bunkerPixels = [
            [0,1,1,1,0],
            [1,1,1,1,1],
            [1,1,1,1,1],
            [1,0,0,0,1],
            [1,0,0,0,1]
        ];
        let bunkers = [];
        let invaders = [];
        let invaderBullets = [];
        const invaderBulletProperties = {
            width: 3,
            height: 7,
            speed: 5,
            color: '#FFFFFF'
        };
        let score = 0;
        const scoreDisplay = document.getElementById('score');
        const levelDisplay = document.getElementById('level'); // Get level display element
        const livesDisplay = document.getElementById('lives');
        let gameOver = false;
        let currentLevel = 1;

        function updateScoreDisplay() {
            scoreDisplay.textContent = score;
        }

        function updateLivesDisplay() {
            livesDisplay.textContent = playerShip.lives;
        }

        function updateLevelDisplay() {
            levelDisplay.textContent = currentLevel;
        }

        function startNewLevel() {
            currentLevel++;
            updateLevelDisplay();
            invaderProperties.speed = currentLevel * 0.5 + 0.5; // Increase speed
            if (currentLevel % 5 === 0) {
                invaderRowCount++;
            }

            // Brief "Level Complete / Get Ready" message - can be enhanced later
            // For now, directly reset invaders.
            // context.fillStyle = 'rgba(0, 0, 0, 0.7)';
            // context.fillRect(0, 0, canvas.width, canvas.height);
            // context.fillStyle = 'white';
            // context.font = '30px sans-serif';
            // context.textAlign = 'center';
            // context.fillText(`Level ${currentLevel -1} Complete!`, canvas.width / 2, canvas.height / 2 - 20);
            // context.fillText(`Get Ready for Level ${currentLevel}`, canvas.width / 2, canvas.height / 2 + 20);
            // setTimeout(() => { // Clear message and start next level
            // createInvaders(); // This needs to be called after timeout or keypress
            // gameLoop(); // Potentially restart gameLoop if it was stopped
            // }, 3000); // 3 second pause

            bullets.length = 0; // Clear bullets
            invaders.length = 0; // Clear previous invaders before creating new ones
            createInvaders(); // Repopulate invaders for the new level
        }

        function createInvaders() {
            invaders.length = 0; // Clear existing invaders
            for (let r = 0; r < invaderRowCount; r++) {
                for (let c = 0; c < invaderProperties.columnCount; c++) {
                    invaders.push({
                        x: invaderProperties.offsetLeft + c * (invaderProperties.width + invaderProperties.padding),
                        y: invaderProperties.offsetTop + r * (invaderProperties.height + invaderProperties.padding),
                        width: invaderProperties.width,
                        height: invaderProperties.height,
                        status: 1, // 1 for alive
                        type: r % 3
                    });
                }
            }
        }

        function drawInvaders() {
            for (let i = 0; i < invaders.length; i++) {
                if (invaders[i].status === 1) {
                    const invader = invaders[i];
                    const sprite = alienSprites[invader.type];
                    context.fillStyle = invaderProperties.color;
                    for (let y = 0; y < sprite.length; y++) {
                        for (let x = 0; x < sprite[y].length; x++) {
                            if (sprite[y][x] === 1) {
                                context.fillRect(invader.x + x * 3, invader.y + y * 3, 3, 3);
                            }
                        }
                    }
                }
            }
        }

        function createBunkers() {
            const bunkerWidth = bunkerPixels[0].length * bunkerSize;
            const spacing = (canvas.width - 4 * bunkerWidth) / 5;
            for (let i = 0; i < 4; i++) {
                const bunkerX = spacing * (i + 1) + bunkerWidth * i;
                const bunkerY = 450;
                let pixels = [];
                for (let r = 0; r < bunkerPixels.length; r++) {
                    pixels[r] = bunkerPixels[r].slice();
                }
                bunkers.push({ x: bunkerX, y: bunkerY, pixels: pixels });
            }
        }

        function drawBunkers() {
            context.fillStyle = '#00FF00'; // Green
            for (let i = 0; i < bunkers.length; i++) {
                const bunker = bunkers[i];
                for (let r = 0; r < bunker.pixels.length; r++) {
                    for (let c = 0; c < bunker.pixels[r].length; c++) {
                        if (bunker.pixels[r][c] === 1) {
                            context.fillRect(bunker.x + c * bunkerSize, bunker.y + r * bunkerSize, bunkerSize, bunkerSize);
                        }
                    }
                }
            }
        }

        function drawShip() {
            if (playerShip.state === 'exploding') {
                context.fillStyle = '#FF0000'; // Red for explosion
                for (let y = 0; y < playerExplosionSprite.length; y++) {
                    for (let x = 0; x < playerExplosionSprite[y].length; x++) {
                        if (playerExplosionSprite[y][x] === 1) {
                            context.fillRect(playerShip.x + x * 5, playerShip.y + y * 5, 5, 5);
                        }
                    }
                }
            } else if (playerShip.state === 'alive' || (playerShip.state === 'respawning' && playerShip.explodeTime % 10 < 5)) {
                context.fillStyle = playerShip.color;
                // Base of the ship
                context.fillRect(playerShip.x, playerShip.y, playerShip.width, playerShip.height);
                // Cannon
                context.fillRect(playerShip.x + playerShip.width / 2 - 5, playerShip.y - 10, 10, 10);
            }
        }

        function drawBullets() {
            context.fillStyle = bulletProperties.color;
            for (let i = 0; i < bullets.length; i++) {
                const bullet = bullets[i];
                context.fillRect(bullet.x, bullet.y, bulletProperties.width, bulletProperties.height);
            }
        }

        function invaderShoot(invader) {
            invaderBullets.push({
                x: invader.x + invader.width / 2,
                y: invader.y + invader.height,
                width: invaderBulletProperties.width,
                height: invaderBulletProperties.height
            });
        }

        function drawInvaderBullets() {
            context.fillStyle = invaderBulletProperties.color;
            for (let i = 0; i < invaderBullets.length; i++) {
                const bullet = invaderBullets[i];
                context.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
            }
        }

        function checkPlayerCollision(bullet) {
            if (bullet.x < playerShip.x + playerShip.width &&
                bullet.x + invaderBulletProperties.width > playerShip.x &&
                bullet.y < playerShip.y + playerShip.height &&
                bullet.y + invaderBulletProperties.height > playerShip.y) {
                return true;
            }
            return false;
        }

        function checkBunkerCollision(bullet) {
            for (let i = 0; i < bunkers.length; i++) {
                const bunker = bunkers[i];
                for (let r = 0; r < bunker.pixels.length; r++) {
                    for (let c = 0; c < bunker.pixels[r].length; c++) {
                        if (bunker.pixels[r][c] === 1) {
                            const pixelX = bunker.x + c * bunkerSize;
                            const pixelY = bunker.y + r * bunkerSize;
                            if (bullet.x < pixelX + bunkerSize &&
                                bullet.x + bulletProperties.width > pixelX &&
                                bullet.y < pixelY + bunkerSize &&
                                bullet.y + bulletProperties.height > pixelY) {
                                bunker.pixels[r][c] = 0; // Destroy the pixel
                                return true; // Collision detected
                            }
                        }
                    }
                }
            }
            return false; // No collision
        }

        document.addEventListener('keydown', function(event) {
            if (gameOver || playerShip.state !== 'alive') return; // Prevent input if game is over or player is not alive

            if (event.key === 'ArrowLeft') {
                playerShip.x -= playerShip.speed;
            } else if (event.key === 'ArrowRight') {
                playerShip.x += playerShip.speed;
            } else if (event.code === 'Space') {
                const newBullet = {
                    x: playerShip.x + playerShip.width / 2 - bulletProperties.width / 2,
                    y: playerShip.y,
                };
                bullets.push(newBullet);
                playShootSound(); // Play sound when shooting
            }

            // Boundary checks
            if (playerShip.x < 0) {
                playerShip.x = 0;
            }
            if (playerShip.x + playerShip.width > canvas.width) {
                playerShip.x = canvas.width - playerShip.width;
            }
        });

        function gameLoop() {
            if (gameOver) {
                context.fillStyle = 'rgba(0, 0, 0, 0.75)'; // Semi-transparent overlay
                context.fillRect(0, 0, canvas.width, canvas.height);
                context.fillStyle = 'white';
                context.font = '48px sans-serif';
                context.textAlign = 'center';
                context.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 30);
                context.font = '24px sans-serif';
                context.fillText('Final Score: ' + score, canvas.width / 2, canvas.height / 2 + 20);
                return; // Stop the game loop
            }

            // Clear the canvas (already happens if canvas has a CSS background color,
            // but if drawing background via JS, this clearRect might be removed or happen after bg fill)
            // For now, assuming CSS background handles the black canvas, so clearRect is fine.
            // If we were filling background in JS:
            // context.fillStyle = '#000000';
            // context.fillRect(0, 0, canvas.width, canvas.height);
            context.clearRect(0, 0, canvas.width, canvas.height);


            // Update ship position (already handled by keydown listener, which checks gameOver)
            if (playerShip.state === 'exploding') {
                playerShip.explodeTime--;
                if (playerShip.explodeTime === 0) {
                    playerShip.state = 'respawning';
                    playerShip.x = canvas.width / 2 - 20; // Reset position
                    playerShip.explodeTime = 120; // 2 seconds of invincibility
                }
            } else if (playerShip.state === 'respawning') {
                playerShip.explodeTime--;
                if (playerShip.explodeTime === 0) {
                    playerShip.state = 'alive';
                }
            }

            // Update bullets positions
            for (let i = bullets.length - 1; i >= 0; i--) {
                bullets[i].y -= bulletProperties.speed;
                if (checkBunkerCollision(bullets[i])) {
                    bullets.splice(i, 1);
                    continue;
                }
                // Remove bullet if it goes off-screen (top)
                if (bullets[i].y + bulletProperties.height < 0) {
                    bullets.splice(i, 1);
                }
            }

            // Invader shooting
            if (Math.random() < 0.01) { // Adjust probability as needed
                const shootingInvaders = invaders.filter(invader => invader.status === 1);
                if (shootingInvaders.length > 0) {
                    const randomInvader = shootingInvaders[Math.floor(Math.random() * shootingInvaders.length)];
                    invaderShoot(randomInvader);
                }
            }

            // Update invader bullets positions
            for (let i = invaderBullets.length - 1; i >= 0; i--) {
                invaderBullets[i].y += invaderBulletProperties.speed;
                if (checkBunkerCollision(invaderBullets[i])) {
                    invaderBullets.splice(i, 1);
                    continue;
                }
                if (playerShip.state === 'alive' && checkPlayerCollision(invaderBullets[i])) {
                    invaderBullets.splice(i, 1);
                    playerShip.lives--;
                    updateLivesDisplay();
                    if (playerShip.lives === 0) {
                        gameOver = true;
                    } else {
                        playerShip.state = 'exploding';
                        playerShip.explodeTime = 60; // 1 second at 60fps
                        playExplosionSound();
                    }
                    continue;
                }
                // Remove bullet if it goes off-screen (bottom)
                if (invaderBullets[i].y > canvas.height) {
                    invaderBullets.splice(i, 1);
                }
            }

            // Update invaders positions & Check Game Over
            let edgeReached = false;
            for (let i = 0; i < invaders.length; i++) {
                if (invaders[i].status === 1) {
                    invaders[i].x += invaderProperties.speed * invaderProperties.moveDirection;
                    if (invaders[i].x + invaders[i].width > canvas.width || invaders[i].x < 0) {
                        edgeReached = true;
                    }
                    // Check for Game Over by invaders reaching bottom
                    if (invaders[i].y + invaders[i].height >= canvas.height) {
                        gameOver = true;
                        // gameLoop will handle display and exit on next iteration
                    }
                }
            }

            if (edgeReached) {
                invaderProperties.moveDirection *= -1;
                for (let i = 0; i < invaders.length; i++) {
                    if (invaders[i].status === 1) { // Only move active invaders
                        invaders[i].y += invaderProperties.height;
                        // Check again if invaders reached bottom after moving down
                        if (invaders[i].y + invaders[i].height >= canvas.height) {
                            gameOver = true;
                        }
                    }
                }
            }

            // Detect Collisions & Check for Level Completion
            let activeInvadersCount = 0;
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                for (let j = invaders.length - 1; j >= 0; j--) {
                    const invader = invaders[j];
                    if (invader.status === 1) {
                        if (bullet.x > invader.x &&
                            bullet.x < invader.x + invader.width &&
                            bullet.y > invader.y &&
                            bullet.y < invader.y + invader.height) {

                            invader.status = 0;
                            playExplosionSound(); // Play sound on invader hit
                            bullets.splice(i, 1);
                            score += 10;
                            updateScoreDisplay();
                            // No need to count active invaders here again, will do it once after collision checks
                            break;
                        }
                    }
                }
            }

            // Check for level completion after processing all collisions
            activeInvadersCount = 0; // Recalculate active invaders
            for(let k=0; k < invaders.length; k++){
                if(invaders[k].status === 1){
                    activeInvadersCount++;
                }
            }

            if (activeInvadersCount === 0 && invaders.length > 0) { // invaders.length > 0 ensures it's not before first level creation
                startNewLevel();
            }

            // Draw everything
            drawBunkers();
            drawShip();
            drawBullets(); // Draw remaining bullets
            drawInvaderBullets();
            drawInvaders(); // Draw remaining invaders

            // Request next frame
            requestAnimationFrame(gameLoop);
        }

        // Initialize
        updateLevelDisplay(); // Display initial level
        updateLivesDisplay();
        createBunkers();
        createInvaders();
        updateScoreDisplay(); // Display initial score
        // Start the game loop
        gameLoop();
    </script>
</body>
</html>
